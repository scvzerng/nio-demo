### NIO (java non-blocking IO) 
> java非阻塞IO jdk1.4

对比

- 传统IO `socket.accept()` `socket.read()` `socket.write()` 为阻塞方法
- NIO 都为非阻塞方法

---

所有的系统I/O都分为两个阶段：等待就绪和操作。
举例来说，读函数，分为等待系统可读和真正的读；
同理，写函数分为等待网卡可以写和真正的写。

---

需要说明的是等待就绪的阻塞是不使用CPU的，是在“空等”；
而真正的读写操作的阻塞是使用CPU的，
真正在"干活"，而且这个过程非常快，属于memory copy，
带宽通常在1GB/s级别以上，可以理解为基本不耗时

---

BIO模型，之所以需要多线程，是因为在进行I/O操作的时候，
一是没有办法知道到底能不能写、能不能读，只能"傻等"，
即使通过各种估算，算出来操作系统没有能力进行读写，
也没法在socket.read()和socket.write()函数中返回，
这两个函数无法进行有效的中断。所以除了多开线程另起炉灶，
没有好的办法利用CPU

---

NIO的读写函数可以立刻返回，
这就给了我们不开线程利用CPU的最好机会：
如果一个连接不能读写（socket.read()返回0或者socket.write()返回0），
我们可以把这件事记下来，
记录的方式通常是在Selector上注册标记位，
然后切换到其它就绪的连接（channel）继续进行读写

#### NIO主要事件

- 读就绪 `通道有数据可以读了`
- 写就绪 `可以向通道写入数据`
- 有新连接到来 


[引用自知乎](https://zhuanlan.zhihu.com/p/23488863)